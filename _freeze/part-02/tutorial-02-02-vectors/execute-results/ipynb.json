{
  "hash": "0880df482c8f485dda30007b8ff76702",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Tutorial II.II - Vectors and Matrices\"\nsubtitle: \"Applied Optimization with Julia\"\n\nformat:\n    html:\n        theme: litera\n        highlight-style: arrow\n        linkcolor: \"#a60000\"\n        code-copy: true\n        code-link: true\n        toc: true\n        toc-location: right\n        code-overflow: wrap\n    pdf: \n        documentclass: report\n        geometry:\n            - margin=1in\n        fontfamily: roboto\n        fontfamilyoptions: sfdefault\n        colorlinks: true\n    ipynb:\n        code-copy: true\n        code-overflow: wrap\n\nengine: julia\n---\n\n\n\n\n\n\n\n\n# Introduction\n\nThis interactive Julia script introduces the basics of vectors, matrices, and tuples.\n\n- A vector is like a single row in a spreadsheet or a shopping list - it stores items in a line\n- A matrix is like a spreadsheet - it has rows and columns\n- A tuple is like a sealed package containing different types of items\n\n Understanding these data structures and how to manipulate them is crucial in Julia. Follow the instructions, write your code in the designated code blocks, and execute the corresponding code cell.\n\n:::{.callout-note}\nIf a cell is marked with `YOUR CODE BELOW`, you are expected to write your code in that cell.\n:::\n\n# Section 1 - Vectors\n\nVectors in Julia are one-dimensional arrays used to store sequences of elements. They're powerful for numerical operations and data handling. A vector is the simplest way to store a list of items. Think of it as a row of boxes, where each box can hold a number or other type of data. Create vectors with square brackets, separate elements with commas.\n\n\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\n# Creating a simple vector (list) of numbers\ngrades = [95, 87, 91, 78, 88]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n5-element Vector{Int64}:\n 95\n 87\n 91\n 78\n 88\n```\n:::\n:::\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\n# Creating a vector of names\nstudents = [\"Mike\", \"Yola\", \"Elio\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{String}:\n \"Mike\"\n \"Yola\"\n \"Elio\"\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nVectors are mutable, and you can:\n\n- Add items to the end (like adding to a shopping list): `push!(grades, 82)`\n- Remove the last item (like crossing off the last item): `pop!(grades)`\n- Remove the first item (like crossing off the first item): `popfirst!(grades)`\n- Look at specific items using their position number: `grades[1]` gives you the first grade\n- Access a range of items: `grades[1:3]` gives you the first three grades\n\n:::{.callout-tip}\nIn Julia, we start counting positions from 1, not 0. So `grades[1]` gives you the first grade!\n:::\n\nUse '?' in the REPL for function details.\n\n## Exercise 1.1 - Create a Vector\n\nCreate a vector 'fib' with the first five Fibonacci numbers: `1, 1, 2, 3, 5`.\n\n\n\n\n\n\n\n\n::: {#6 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#8 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Test your answer\n@assert fib == [1, 1, 2, 3, 5]\nprintln(\"The 'fib' vector: \", fib)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Exercise 1.2 - Append to a Vector\n\nAppend the number 8 to the `fib` vector.\n\n\n\n\n\n\n\n\n::: {#10 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#12 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Test your answer\n@assert fib == [1, 1, 2, 3, 5, 8]\nprintln(\"The 'fib' vector after appending 8: \", fib)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Exercise 1.3 - Remove the First Element\n\nRemove the first element of the `fib` vector. \n\n\n\n\n\n\n\n\n::: {#14 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#16 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Test your answer\n@assert fib == [1, 2, 3, 5, 8]\nprintln(\"The 'fib' vector after removing the first element: \", fib)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Exercise 1.4 - Access and Save the First Three Elements\n\nAccess and save the first three elements of `fib`, to `first_three_elements`.\n\n\n\n\n\n\n\n\n::: {#18 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#20 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Test your answer\n@assert first_three_elements == fib[1:3]\nprintln(\"The first three elements of the 'fib' vector: \", first_three_elements)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# Section 2 - Matrices\n\nA matrix in Julia is a 2D array, great for linear algebra and data representation. Create matrices with square brackets, separate elements with spaces, rows with semicolons. Access elements with square brackets (e.g., `matrix[2,2]`). You can add or substract matrices of the same dimensions element-wise if you add or substract them.\n\nFor example:\n\n\n\n\n\n\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code}\nmatrix1 = [2 2; 3 3] + [1 2; 3 4]\nmatrix2 = [2 2; 3 3] - [1 2; 3 4]\nprintln(\"matrix1 is $matrix1.\")\nprintln(\"matrix2 is $matrix2.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmatrix1 is [3 4; 6 7].\nmatrix2 is [1 0; 0 -1].\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nIf you want to perform multiplications, things are a bit different, as matrix multiplications are not performed element-wise!\n\n\n\n\n\n\n\n\n::: {#24 .cell execution_count=1}\n``` {.julia .cell-code}\nmatrix3 = [2 2; 3 3] * [1 2; 3 4]   # Not element-wise\nprintln(\"matrix3 is $matrix3.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmatrix3 is [8 12; 12 18].\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nBut we can change this by using broadcasting! \n\n:::{.callout-tip}\nJulia's broadcasting feature allows you to apply functions element-wise to arrays of different sizes. This is denoted by adding a dot (.) before the operator or function. It is extremely useful for performing operations on arrays without the need to loop through each element.\n:::\n\n\n\n\n\n\n\n\n::: {#26 .cell execution_count=1}\n``` {.julia .cell-code}\nmatrix4 = [1 2; 3 4]\nmatrix4 = matrix4 .+ 1\nprintln(\"matrix4 is $matrix4.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmatrix4 is [2 3; 4 5].\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nWe can also use this to perform element-wise multiplications, as shown below:\n\n\n\n\n\n\n\n::: {#28 .cell execution_count=1}\n``` {.julia .cell-code}\nmatrix5 = [2 2; 3 3] .* [1 2; 3 4]  # Element-wise\nprintln(\"matrix5 is $matrix5.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmatrix5 is [2 4; 9 12].\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n## Exercise 2.1 - Create a Matrix\n\nCreate a 2x3 matrix `my_matrix` with the values: `1 2 3; 4 5 6`.\n\n\n\n\n\n\n\n\n::: {#30 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#32 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Test your answer\n@assert my_matrix == [1 2 3; 4 5 6]\nprintln(\"The 'my_matrix':\\n\", my_matrix)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Exercise 2.2 - Change the 3rd Column of the 2nd Row\n\nChange the 3rd column of the 2nd row to `17` by accessing and changing the element.\n\n\n\n\n\n\n\n\n::: {#34 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n\n```\n:::\n\n\n\n::: {#36 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Test your answer\n@assert my_matrix == [1 2 3; 4 5 17]\nprintln(\"The 'my_matrix' after modification:\\n\", my_matrix)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Exercise 2.3 - Perform Matrix Addition\n\nPerform matrix addition with `my_matrix` and `another_matrix`. Call the resulting matrix `added_matrices`.\n\n\n\n\n\n\n\n\n::: {#38 .cell execution_count=0}\n``` {.julia .cell-code}\nanother_matrix = [10 20 30; 40 50 60]\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#40 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Test your answer\n@assert added_matrices == [11 22 33; 44 55 77]\nprintln(\"Result of adding 'my_matrix' and 'another_matrix':\\n\", added_matrices)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Exercise 2.4 - Add 10 to Each Element\n\nAdd `10` to each element in `added_matrices`.\n\n\n\n\n\n\n\n\n::: {#42 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#44 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Test your answer\n@assert added_matrices == [21 32 43; 54 65 87]\nprintln(\"Result of adding 10 to each element in 'added_matrices':\\n\", added_matrices)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# Section 3: Tuples\n\nA tuple is like a sealed package - once you create it, you can't change what's inside. That's why we call it \"immutable\". It's perfect for grouping related items that shouldn't change. For example:\n\n```julia\n# A person's basic info that won't change\nperson = (\"Elio Smith\", 18, \"Hamburg\")\n\n# RGB color values\nred = (255, 0, 0)\n```\n\nThink of tuples as permanent labels - once you write them, they can't be changed. This is useful when you want to make sure data stays exactly as you set it.\n\n## Exercise 3.1 - Create a Tuple\n\nCreate a tuple `my_tuple` with three elements: `4.0`, your matrix `added_matrices`, and `\"Hi there!\"`.\n\n\n\n\n\n\n\n\n::: {#46 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#48 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Test your answer\n@assert my_tuple == (4.0, added_matrices, \"Hi there!\")\nprintln(\"The 'my_tuple': \", my_tuple)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Exercise 3.2 - Access the Second Element\n\nAccess the second element of `my_tuple`, store it in `second_element`.\n\n\n\n\n\n\n\n\n::: {#50 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#52 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Test your answer\n@assert second_element == [21 32 43; 54 65 87]\nprintln(\"The second element of 'my_tuple':\\n\", second_element)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# Conclusion\n\nWell done! You've completed the tutorial on Vectors, Matrices, and Tuples. You've learned to create, manipulate, and interact with these fundamental data structures. Experiment with the code, try different operations, and see how Julia behaves. Continue to the next file to learn more.\n\n\n# Solutions\n\nYou will likely find solutions to most exercises online. However, I strongly encourage you to work on these exercises independently without searching explicitly for the exact answers to the exercises. Understanding someone else's solution is very different from developing your own. Use the lecture notes and try to solve the exercises on your own. This approach will significantly enhance your learning and problem-solving skills.\n\nRemember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities. If you encounter difficulties, review the lecture materials, experiment with different approaches, and don't hesitate to ask for clarification during class discussions.\n\nLater, you will find the solutions to these exercises online in the associated GitHub repository, but we will also quickly go over them in next week's tutorial. To access the solutions, click on the Github button on the lower right and search for the folder with today's lecture and tutorial. Alternatively, you can ask ChatGPT or Claude to explain them to you. But please remember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities.\n\n---\njupyter:\n  kernelspec:\n    display_name: Julia\n    name: julia\n    language: julia\n  kernel_info:\n    name: julia\n  language_info:\n    name: julia\n    version: 1.10.5\n    codemirror_mode: julia\n---\n",
    "supporting": [
      "tutorial-02-02-vectors_files/figure-ipynb"
    ],
    "filters": []
  }
}