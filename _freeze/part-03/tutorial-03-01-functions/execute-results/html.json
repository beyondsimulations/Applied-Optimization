{
  "hash": "0a9992663ae5c1345fc53639b5b3277b",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Tutorial III.I - Functions in Julia\"\nsubtitle: \"Applied Optimization with Julia\"\n\nformat:\n    html:\n        theme: litera\n        highlight-style: arrow\n        linkcolor: \"#a60000\"\n        code-copy: true\n        code-link: true\n        toc: true\n        toc-location: right\n        code-overflow: wrap\n    pdf: \n        documentclass: report\n        geometry:\n            - margin=1in\n        fontfamily: roboto\n        fontfamilyoptions: sfdefault\n        colorlinks: true     \n    ipynb:\n        code-copy: true\n        code-overflow: wrap\n\nengine: julia\n---\n\n\n\n\n\n\n\n\n# Introduction\n\nImagine you have a helpful worker. Instead of explaining every little task to it each time, you can teach it specific jobs once, and then just ask it to do those jobs later. In programming, these \"jobs\" are called functions! This tutorial will show you how to create and use functions in Julia, making your code more organized and reusable.\n\nFollow the instructions, input your code in the designated areas, and verify your implementations with `@assert` statements.\n\n# Section 1 - Creating and Calling Functions\n\nFunctions in Julia encapsulate reusable code and can be defined using the `function` keyword or shorthand syntax. After the keyword, you name the function and write the parameters in parentheses. Later, you can call the function by writing the name of the function followed by the parameters in parentheses.\n\nThus, think of a function like a recipe:\n\n1. It has a name (like \"say_something\")\n2. It might need ingredients (our \"parameters\")\n3. It has steps to follow (the code inside the function)\n4. It usually produces something (we call this the \"return value\")\n\nLet's see some examples:\n\n\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\n# A simple function to greet someone\nfunction say_hello(name)\n    return \"Hello, $(name)!\"\nend\n\n# Using our function\nmessage = say_hello(\"Elio\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Hello, Elio!\"\n```\n:::\n:::\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction multiply(a,b)\n   a * b\nend\nmultiply(10, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n50\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nThe second function takes two parameters, multiplies them, and returns the result implicitly. In Julia, the last expression is automatically returned, making the `return` keyword optional. If you explicitly use the `return` keyword in the function, it will return the value immediately once the function encounters the keyword and stops the further execution of the function. That way, you can also use the keyword in conditional statements and use it to return a value based on a condition. For example:\n\n\n\n\n\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction do_something(a,b)\n   if a > b\n      return a * b\n   else\n      return a + b\n   end\nend\nprintln(\"The result of do_something(10, 5) is $(do_something(10, 5))\")\nprintln(\"The result of do_something(5, 10) is $(do_something(5, 10))\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe result of do_something(10, 5) is 50\nThe result of do_something(5, 10) is 15\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n:::{.callout-tip}\nFunctions are like teaching a robot new skills:\n\n- The function name is like the skill name (e.g., \"make_sandwich\")\n- Parameters are things the robot needs to do the job (e.g., bread, filling)\n- The code inside are the steps to follow\n- The return value is the finished product\n:::\n\n## Exercise 1.1 - Define and Test a Simple Addition Function\n\nDefine and test a simple addition function. Define a function `add` that takes two parameters and returns their sum.\n\n\n\n\n\n\n\n\n::: {#8 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#10 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Test your answer\n@assert add(10, 5) == 15 \"The sum computed is $(add(10, 5)) but should be 15.\"\nprintln(\"The sum computed is $(add(10, 5)), wonderful!\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# Section 2 - Scope within Functions\n\nWhen you create variables inside a function, they're like secret ingredients - they only exist inside that function's \"kitchen\". We call this \"local scope\". Thus, variables declared inside a function are local to that function and are not accessible outside. \n\n\n\n\n\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction bake_cake()\n    secret_ingredient = \"vanilla extract\"\n    println(\"Adding the secret ingredient: $secret_ingredient\")\nend\nbake_cake()  # This works fine\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAdding the secret ingredient: vanilla extract\n```\n:::\n:::\n\n\n\n::: {#14 .cell execution_count=0}\n``` {.julia .cell-code}\n# But this would cause an error:\nprintln(secret_ingredient)\n```\n:::\n\n\n\n\n\n\n\n\n\n\nIf you want to access the variable outside of the function, you have to explicitly return it. You can do this by passing `return` in front of the variable you want to return from the function.\n\n## Exercise 2.1 - Return a Local Variable\n\nTry to execute the following block of code. The objective is to understand how to return the `local_variable_one` from the function `scope_test`. Your task is to change the function, to return the value of `local_variable_one`.\n\n\n\n\n\n\n\n\n::: {#16 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CHANGES BELOW\nfunction scope_test()\n    local_variable_one = 10\n    local_variable_two = 20\nend\n# YOUR CHANGES ABOVE\n```\n:::\n\n\n\n::: {#18 .cell execution_count=0}\n``` {.julia .cell-code}\n# Test your function\n@assert scope_test() == 10 \"The value exported is $(scope_test()).\"\nprintln(\"The value exported is $(scope_test()), you solved it!\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Exercise 2.2 - Define an Implicit Return Function\n\nDefine and test an implicit return function. Define a function `subtract` that takes two parameters and implicitly returns their difference. The implicit return feature makes your code cleaner and more concise.\n\n\n\n\n\n\n\n\n::: {#20 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#22 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Test your answer\n@assert subtract(10, 5) == 5  \"The difference computed is $(subtract(10, 5)) but should be 5.\"\nprintln(\"The difference computed is $(subtract(10, 5)), perfect!\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# Section 3 - Multiple Dispatch\n\nMultiple dispatch in Julia allows defining function behavior based on argument types, promoting code reuse and clarity. It's a powerful feature for designing flexible and extensible functions. We first define a generic version and then provide specific implementations for different types:\n\n\n\n\n\n\n\n\n::: {#24 .cell execution_count=1}\n``` {.julia .cell-code}\n# Generic operation for objects of all types.\nfunction operation(a, b)\n    \"Generic operation for objects of type $(typeof(a)) and $(typeof(b))\"\nend\n\n# The specific implementations are:\noperation(a::Number, b::Number) = a + b        # Specific method for Number types.\noperation(a::String, b::String) = string(a, b) # Specific method for String types.\n\n# Test with different types of arguments.\nresult1 = operation(10, 20)\nprintln(result1)\nresult2 = operation(\"Hello, \", \"World!\")\nprintln(result2)\nresult3 = operation(\"Hello, \", 20)\nprintln(result3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n30\nHello, World!\nGeneric operation for objects of type String and Int64\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n## Exercise 3.1 - Match Results to Assertions\n\nMatch the results from the previous example to the correct assertions:\n\n\n\n\n\n\n\n\n::: {#26 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CHANGES BELOW\n@assert result2 == 30 \"result1 should be the sum of two numbers\"\n@assert result3 == \"Hello, World!\" \"result2 should be the concatenation of two strings\"\n@assert result1 == \"Generic operation for objects of type String and Int64\" \"result3 should use the generic operation\"\nprintln(\"You solved it, the assertions are now correct!\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\n::: {.callout-tip}\n**Hint**: Look at the types of arguments used in each `operation` call and match them to the appropriate method.\n:::\n\n# Conclusion\n\nGreat work! You've just completed the tutorial on functions in Julia. You now have a first understanding of how to create, use, and understand functions in Julia. Continue to the next file to learn more.\n\n\n# Solutions\n\nYou will likely find solutions to most exercises online. However, I strongly encourage you to work on these exercises independently without searching explicitly for the exact answers to the exercises. Understanding someone else's solution is very different from developing your own. Use the lecture notes and try to solve the exercises on your own. This approach will significantly enhance your learning and problem-solving skills.\n\nRemember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities. If you encounter difficulties, review the lecture materials, experiment with different approaches, and don't hesitate to ask for clarification during class discussions.\n\nLater, you will find the solutions to these exercises online in the associated GitHub repository, but we will also quickly go over them in next week's tutorial. To access the solutions, click on the Github button on the lower right and search for the folder with today's lecture and tutorial. Alternatively, you can ask ChatGPT or Claude to explain them to you. But please remember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities.\n\n",
    "supporting": [
      "tutorial-03-01-functions_files"
    ],
    "filters": [],
    "includes": {}
  }
}