---
title: "Tutorial II.V - Variable Scope"
subtitle: "Applied Optimization with Julia"

format:
    html:
        theme: litera
        highlight-style: arrow
        linkcolor: "#a60000"
        code-copy: true
        code-link: true
        toc: true
        toc-location: right
        code-overflow: wrap
    pdf: 
        documentclass: report
        geometry:
            - margin=1in
        fontfamily: roboto
        fontfamilyoptions: sfdefault
        colorlinks: true
    ipynb:
        code-copy: true
        code-overflow: wrap

engine: julia
---

# Exploration of Variable Scopes in Julia

This interactive Julia script is a look on variable scopes in Julia. Understand the intricacies of local and global scopes, comprehend the significance of 'local' and 'global' keywords, and discern the scope behaviors in different contexts. Follow the structured instructions, implement your code in the designated blocks, and affirm your comprehension with @assert statements.

## Section 1: The Local and Global Scope

In Julia, variables within a function or a loop are encapsulated in a local scope, meaning their visibility and lifespan are confined to that block of code. Variables declared in the main body of a script are in the global scope, making them accessible and modifiable across your entire program. We have seen this in the previous tutorial on Loops, where we have created scope blocks with let ... end to prevent us from creating global variables.

## Exercise 1.1

Experiment with local variables in a `for` loop and try to execute the following block of code.

```{julia}
#| eval: false 
# Experiment with local variables in a `for` loop and try to execute the following block of code:

println("Defining a local variable within a loop:")
for i in 1:3
    loop_variable = i
    println("Inside the loop, loop_variable is: ", loop_variable)
end
println("Outside the loop, loop_variable is: ", loop_variable)

# Test your answer
@assert loop_variable == 3
println("Now, the loop works and the value of the 'loop_variable' is: ", loop_variable)
```

:::{.callout-note}
Attempting to access `loop_variable` here should result in an error because its scope is local to the loop. Can you come up with a way to solve this issue? Extend the code above to allow the execution of the code.
:::

## Exercise 1.2

Experiment with local variables in a nested loop. Try to execute the following block of code.
```{julia}
#| eval: false 
# Experiment with local variables in a nested loop. Try to execute the following block of code:

println("Defining a local variable within a loop:")
for i in 1:3
    nestedloop_variable = 0
    for j in 1:3
        nestedloop_variable = i * 3
        println("Inside the nested loop, loop_variable is: ", nestedloop_variable)
    end
end
println("Outside the nested loop, loop_variable is: ", nestedloop_variable)

# Test your answer
@assert nestedloop_variable == 9
println("Now, the loop works and the value of the 'nestedloop_variable' is: ", nestedloop_variable)
```

:::{.callout-note}
Attempting to access `nestedloop_variable` here should result in an error because its scope is only accessible in the first loop, where it is defined, and the second loop below. Can you come up with a way to solve this issue? Extend the code above to allow the execution of the code.
:::

## Section 2: Working with `global` and `local` Keywords

Use 'global' to designate a global variable inside a local scope. Conversely, 'local' 
explicitly defines a local variable, particularly in contexts where global inference 
might occur.

## Exercise 2.1

Experiment with local variables in a potentially global context using `local`. The objective is to redefine the value of 'explicit_local_variable' to "end" within the following loop. Try to execute the following block of code.

```{julia}
#| eval: false 
# Experiment with local variables in a potentially global context using `local`. The objective is to redefine the value of 'explicit_local_variable' to "end" within the following loop. Try to execute the following block of code:

explicit_local_variable = "start"
println("At the start of the loop, explicit_local_variable is: ", explicit_local_variable)
for i in 1:3
    local explicit_local_variable = "end"
    println("Inside the loop, explicit_local_variable is: ", explicit_local_variable)
end
println("Outside the loop, explicit_local_variable is: ", explicit_local_variable)

# Test your answer
@assert explicit_local_variable == "end" "Currently, the value of 'explicit_local_variable' is $explicit_local_variable."
```

:::{.callout-note}
Attempting to access `explicit_local_variable` here should result in an error because its scope is local to the loop. Can you come up with a way to solve this issue? Extend the code above to allow the execution of the code.
:::

## Conclusion
Great You've just navigated through the variable scopes in Julia. Use this knowledge to create precise, robust, and efficient programs. Continue to the next file to learn more.

{{< include ../include/tutorial_end.qmd >}}