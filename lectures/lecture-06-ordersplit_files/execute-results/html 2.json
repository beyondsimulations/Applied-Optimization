{
  "hash": "7cc82a557b67756c97c804ecede28894",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Lecture VI - Minimizing Split Orders in E-Commerce\"\nsubtitle: \"Applied Optimization with Julia\"\nauthor: \"Dr. Tobias Vlćek\"\nformat:\n  revealjs:\n    footer: \" {{< meta title >}} | {{< meta author >}} | [Home](lecture-06-ordersplit.qmd)\"\n    output-file: lecture-06-presentation.html\n---\n\n# [Introduction]{.flow} {.title}\n\n## [E-Commerce Trends]{.invert-font} {background-color=\"#000000\" background-image=\"https://images.unsplash.com/photo-1585144860131-245d551c77f6?q=80&w=5404&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\" background-size=\"cover\" background-position=\"center\"}\n\n[**Question:** What are current trends in e-commerce?]{.invert-font .fragment}\n\n::: footer\n:::\n\n\n## E-Commerce Sales\n\n\n\n- E-Commerce sales [are growing fast]{.highlight}:\n    - Products are **no longer bound between borders**\n    - Product variety is **rising**\n    - Consumer shopping patterns are **shifting **\n    - Brick-and-mortar stores **loose customers to the internet**\n    - Covid-19 **accelerated this trend even more**\n\n## Parcels Worldwide\n\n- The number of parcels is rising:\n    - **2014**: 44 billion parcels [@PitneyBowes2017]\n    - **2019**: 103 billion parcels [@PitneyBowes2019]\n    - **2026**: 220 – 262 billion parcels [^0] [@PitneyBowes2020]\n\n[^0]: Forecast, not actual number\n\n## Pressure on infrastructure\n\n::: {.columns}\n::: {.column width=\"40%\"}\n[![](https://images.unsplash.com/photo-1605902711834-8b11c3e3ef2f?q=80&w=2832&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D){width=\"90%\"}](https://unsplash.com/photos/person-holding-black-samsung-android-smartphone-hTUZW7E7krg){width=\"85%\"}\n:::\n\n::: {.column width=\"60%\"}\n- Consumers nowadays expect [free and fast deliveries and returns]{.highlight}\n- Existing warehouses have to store an **increasing range of products**\n- Better customer service requires **faster deliveries**\n- Incurred fulfillment costs **depend on the number of parcels**\n:::\n:::\n\n## Pressure on the environment\n\n::: {.columns}\n::: {.column width=\"40%\"}\n[![](https://images.unsplash.com/photo-1606942298712-8bd250ff40f0?q=80&w=2398&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D){width=\"90%\"}](https://unsplash.com/photos/white-and-red-cars-parked-near-white-concrete-building-during-daytime-4jLpCkGqClE){width=\"85%\"}\n:::\n\n::: {.column width=\"60%\"}\n- **Each parcel packaging** consumes resources during production\n- Every dispatched parcel to the customer [causes CO₂ emissions]{.highlight}\n- In case of returns, **more parcels cause more emissions**\n:::\n:::\n\n---\n\n# [Problem Structure]{.flow} {.title}\n\n## Split Order\n\n[Question:]{.question} **What is a split order?**\n\n. . .\n\n![](https://images.beyondsimulations.com/ao/ao_split-unoptimized.png){width=\"75%\" .center}\n\n\n## No Split Order\n\n![](https://images.beyondsimulations.com/ao/ao_split-optimized.png){width=\"75%\" .center}\n\n## Reason for Split Orders\n\n[Question:]{.question} **Why might they occur?**\n\n. . .\n\n- **Stock availability**: Some products are [out of stock]{.highlight} at a warehouse and need to be fulfilled from another warehouse\n- **Capacity constraints**: Some products are stored at [different warehouses]{.highlight} and need to be shipped from elsewhere\n\n## Impact of Split Orders\n\n[Question:]{.question} **What are the consequences?**\n\n. . .\n\n- **Higher** shipping costs\n- **Increased** packaging material\n- **More** CO₂ emissions\n- [Higher operational complexity]{.highlight}\n- **Lower** customer satisfaction\n\n## Mitigations?\n\n[Question:]{.question} **What are possible mitigations?**\n\n. . .\n\n- **Consolidation**: Ship to a central warehouse before dispatch\n- **Cross-docking**: Ship directly from supplier to customer\n- **Transshipment**: Ship between warehouses before delivery\n- **Co-allocation**: Predict [co-appearance of products]{.highlight} and allocate them to the [same warehouse]{.highlight}\n\n## [Case Study]{.invert-font} {background-color=\"#000000\" background-image=\"https://images.unsplash.com/photo-1672552226380-486fe900b322?q=80&w=3540&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\" background-size=\"cover\" background-position=\"center\"}\n\n::: {.invert-font .fragment}\n**Key information** about the case:\n\n- a large European e-commerce retailer\n- the retailer has two warehouses\n- product range cannot be stored in either warehouse\n- product deliveries can be made to both warehouses\n- products do not have to be stored exclusively\n:::\n\n::: footer\n:::\n\n---\n\n# [Problem Structure - Version 1]{.flow} {.title}\n\n## Optimizing Co-allocation\n\n::: {.columns}\n::: {.column width=\"40%\"}\n![](https://images.beyondsimulations.com/ao/ao_split-suppliers.png){width=\"90%\" .center}\n:::\n\n::: {.column width=\"60%\"}\n[**Question:**]{.question} **What could be our objective?**\n\n\n::: {.fragment}\nWe aim to improve the **SKU[^1]-warehouse allocation** to minimize the number of split parcels resulting from **SKUs being stored in different warehouses**.\n:::\n:::\n:::\n\n[^1]: SKU: Stock Keeping Unit\n\n## Available Sets\n\n[Question:]{.question} **What could be the sets here?**\n\n. . .\n\n::: {.incremental}\n- $\\mathcal{I}$ - Set of products indexed by $i \\in \\{1,2,...,|\\mathcal{I}|\\}$\n- $\\mathcal{K}$ - Set of warehouses indexed by $k \\in \\{1,\\dots,|\\mathcal{K}|\\}$\n- $\\mathcal{M}$ - Set of customer orders $m \\in \\{1,2,...,|\\mathcal{M}|\\}$\n:::\n\n\n## Available Parameters\n\n[Question:]{.question} **What are possible parameters?**\n\n. . .\n\n::: {.incremental}\n- $c_k$ - Storage space of warehouse $k \\in \\{1,\\dots,|\\mathcal{K}|\\}$\n- $\\boldsymbol{T}= (t_{m,i})$ - Past customer orders for SKUs\n:::\n\n. . .\n\n[**Question:**]{.question} **What could the transactional data look like?**\n\n## Transactional Data {.smaller}\n\n| $t_{m,i}$ | A | B | C | D |\n|-----------|---|---|---|---|\n| 1         | 1 | 1 | 1 | 0 |\n| 2         | 1 | 1 | 1 | 0 |\n| 3         | 1 | 1 | 0 | 0 |\n| 4         | 1 | 0 | 0 | 1 |\n| 5         | 1 | 0 | 0 | 1 |\n| 6         | 1 | 0 | 0 | 1 |\n| 7         | 1 | 0 | 0 | 1 |\n| 8         | 0 | 0 | 1 | 1 |\n\n: Example of $\\boldsymbol{T}$\n\n## Past vs. Future\n\n- The [transactional data]{.highlight} $\\boldsymbol{T}$ is based on **past orders**\n- It is a **binary matrix** of customer orders and SKUs\n- We use this data to **assume** future co-occurrence\n    - [Past co-occurrence predicts future co-occurrence]{.highlight}\n\n. . .\n\n[Question:]{.question} **What is your opinion on the assumption?**\n\n---\n\n## Split-Order Minimization\n\n[Question:]{.question} **What could be our decision variable/s?**\n\n. . .\n\n\n::: {.callout-note}\n## We have the following sets:\n- $\\mathcal{I}$ - Set of products indexed by $i \\in \\{1,2,...,|\\mathcal{I}|\\}$\n- $\\mathcal{K}$ - Set of warehouses indexed by $k \\in \\{1,\\dots,|\\mathcal{K}|\\}$\n- $\\mathcal{M}$ - Set of customer orders $m \\in \\{1,2,...,|\\mathcal{M}|\\}$\n:::\n\n. . .\n\n- $X_{i,k}$ - 1, if $i\\in\\mathcal{I}$ is stored in  $k\\in\\mathcal{K}$, 0 otherwise\n- $Y_{m,i,k}$ - 1, if SKU $i\\in\\mathcal{I}$ is shipped from warehouse $k\\in\\mathcal{K}$ for customer order $m\\in\\mathcal{M}$, 0 otherwise\n\n## Integer Programming Model\n\n- @Catalan2012 created an **integer model**\n- Number of SKUs of E-Commerce retailers can easily be **between 10,000 - 100,000**\n- Number of customer orders necessary for \"stable\" results have to be higher in the order of **100,000 - 10,000,000**\n\n. . .\n\n[Question:]{.question} **Anybody an idea what this could mean?**\n\n## Implementation Challenges\n\n- Small instance with 10 SKUs and 1000 customer orders\n- **CPLEX 20.1.0** needs 3100 seconds to solve the problem\n- Computation times scales exponentially\n- $\\rightarrow$ **Not applicable** in real world applications!\n\n## {.loud-slide}\n::: {.r-fit-text}\nAny idea what\n\ncould be done?\n:::\n\n::: footer\n:::\n\n---\n\n# [Problem Structure - Version 2]{.flow} {.title}\n\n## Heuristic Approach\n\n- **Heuristic**: Fast, but not necessarily optimal\n- **Approximation**: Not guaranteed to be optimal, but close\n- **Computational Effort**: Reasonable even for large instances\n\n. . .\n\n::: {.callout-tip}\n## Different view on the problem\nFocus on the warehouses and the co-appearance of SKUs! Discard the exact information about the customer orders.\n:::\n\n## Objective\n\n::: {.columns}\n::: {.column width=\"40%\"}\n\n![](https://images.beyondsimulations.com/ao/ao_split-suppliers.png){width=\"75%\"}\n\n:::\n\n::: {.column width=\"60%\"}\n[Question:]{.question} **What could be the objective?**\n\n[Maximize the coappearance of products that are often **part of the same customer orders**.]{.fragment}\n\n:::\n:::\n\n## Transaction Matrix\n\n::: {#880304b9 .cell output-location='column-fragment' execution_count=2}\n``` {.julia .cell-code}\nT = [\n    1 1 1 0;\n    1 1 1 0;\n    1 1 0 0;\n    1 0 0 1;\n    1 0 0 1;\n    1 0 0 1;\n    1 0 0 1;\n    0 0 1 1\n]\n\n# Create the coappearance matrix\nQ = T' * T\nprintln(\"Coappearance matrix Q:\")\ndisplay(Q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoappearance matrix Q:\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\n4×4 Matrix{Int64}:\n 7  3  2  4\n 3  3  2  0\n 2  2  3  1\n 4  0  1  5\n```\n:::\n:::\n\n\n## Coappearance Matrix\n\n- $\\boldsymbol{Q}$ is a [symmetric matrix]{.highlight}\n- Proposed by @Catalan2012\n- $\\boldsymbol{Q} = (\\boldsymbol{T}^T \\cdot \\boldsymbol{T})$ where $\\boldsymbol{Q} = (q_{ij})_{i \\in \\{1,\\dots,\\mathcal{I}\\},j \\in \\{1,\\dots,\\mathcal{I}\\}}$\n- $q_{ij}$ shows how often $i$ and $j$ appear **in the same order**\n\n. . .\n\n[Question:]{.question} **What do the principal diagonal values tell us?**\n\n. . .\n\n- How often each SKU appeared over all orders **(binary!)**\n\n---\n\n## How to approach the problem?\n\n::: {.incremental}\n- **Greedy Heuristic**[^catalan2012]: Allocation based on matrix\n- **Mathematical Model**[^zhu2021]: Maximizes coappearance\n- **GRASP**[^graps]: Good on small instances\n- [New]{.highlight}: Max. coappearance with non-linear solver\n- [New]{.highlight}: Heuristic based on Chi-Square Tests\n:::\n\n[^catalan2012]: Simple and very fast, @Catalan2012\n[^zhu2021]: Computationally intensive with CPLEX, @Zhu2021\n[^graps]: Greedy Randomized Adaptive Search Procedure, @Zhu2021\n\n## Basic Setting\n\n![](https://images.beyondsimulations.com/ao/ao_split-warehouse.png){width=\"75%\"}\n\n## Available Data (Version 2)\n\n[Question:]{.question} **What could be the sets?**\n\n. . .\n\n- $\\mathcal{I}$ - Set of products indexed by $i \\in \\{1,2,...,|\\mathcal{I}|\\}$\n- $\\mathcal{K}$ - Set of warehouses indexed by $k \\in \\{1,\\dots,|\\mathcal{K}|\\}$\n\n. . .\n\n::: {.callout-important}\n## No customer order information is needed!\nWe can focus on the SKUs and the warehouses, making the problem **much smaller**!\n:::\n\n---\n\n## Available Parameters\n\n[Question:]{.question} **What are possible parameters?**\n\n::: {.incremental}\n- $c_k$ - Storage space of warehouse $k \\in \\{1,\\dots,|\\mathcal{K}|\\}$\n- $\\boldsymbol{Q}= (q_{ij})_{i \\in \\{1,\\dots,\\mathcal{I}\\},j \\in \\{1,\\dots,\\mathcal{I}\\}}$ - Coappearance matrix\n:::\n\n. . .\n\n:::{.callout-important}\n## Transactional Data replaced\nInstead of the transactional data, we just **use the coappearance matrix** in our model!\n:::\n\n---\n\n# [Model Formulation]{.flow} {.title}\n\n## Decision Variables?\n\n::: {.callout-note}\n## We have the following sets:\n- $\\mathcal{I}$ - Set of products indexed by $i \\in \\{1,2,...,|\\mathcal{I}|\\}$\n- $\\mathcal{K}$ - Set of warehouses indexed by $k \\in \\{1,\\dots,|\\mathcal{K}|\\}$\n:::\n\n. . .\n\n::: {.callout-important}\n## Our objective is to:\nMaximize the coappearance of products that are often part of the same customer orders. **In more mathematical terms:** Maximize the sum of all unique pair-wise values $q_{i,j}$ of all SKUs stored in the same warehouse.\n:::\n\n. . .\n\n[Question:]{.question} **What could be our decision variable/s?**\n\n## Decision Variables\n\n- $X_{i,k}$ - 1, if SKU $i\\in\\mathcal{I}$ is stored in  $k\\in\\mathcal{K}$, 0 otherwise\n\n. . .\n\n::: {.callout-important}\n## Only one variable per SKU and warehouse!\nAs we don't need the customer order information, we only need to make a decision for each SKU and warehouse pair!\n:::\n\n## Decision Variable in Julia\n\n[Question:]{.question} **How could we formulate the variable in Julia?**\n\n::: {#49ecf5f1 .cell execution_count=3}\n``` {.julia .cell-code}\nimport Pkg; Pkg.add(\"SCIP\")\nusing JuMP, SCIP # SCIP is a non-commercial MIQCP solver\n\nwarehouses = [\"Hamburg\", \"Berlin\"] # Add warehouses as a vector\nskus = [\"Smartphone\", \"Socks\", \"Charger\"] # Add SKUs as a vector\n\nwarehouse_model = Model(SCIP.Optimizer)\n```\n:::\n\n\n. . .\n\n::: {#831f178d .cell output-location='fragment' execution_count=4}\n``` {.julia .cell-code}\n@variable(warehouse_model, X[i in skus, k in warehouses], Bin)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, [\"Smartphone\", \"Socks\", \"Charger\"]\n    Dimension 2, [\"Hamburg\", \"Berlin\"]\nAnd data, a 3×2 Matrix{VariableRef}:\n X[Smartphone,Hamburg]  X[Smartphone,Berlin]\n X[Socks,Hamburg]       X[Socks,Berlin]\n X[Charger,Hamburg]     X[Charger,Berlin]\n```\n:::\n:::\n\n\n---\n\n## Objective Function\n\n::: {.callout-note}\n## We need the following:\n- $X_{i,k}$ - 1, if SKU $i\\in\\mathcal{I}$ is stored in  $k\\in\\mathcal{K}$, 0 otherwise\n- $q_{ij}$ - Coappearance of SKU $i\\in\\mathcal{I}$ and $j\\in\\mathcal{I}$\n:::\n\n::: {.callout-important}\n## Our objective is to:\nMaximize the sum of all unique pair-wise values $q_{i,j}$ of all SKUs stored in the same warehouse. Note, that this is a **quadratic objective function**!\n:::\n\n. . .\n\n[Question:]{.question} **What could the objective function look like?**\n\n. . .\n\n## Quadratic Objective Function\n\n$$\\text{maximize} \\quad \\sum_{i=2}^{\\mathcal{I}} \\sum_{j=1}^{i-1} \\sum_{k \\in \\mathcal{K}} X_{ik}\\times X_{jk} \\times q_{ij}$$\n\n. . .\n\n::: {.callout-note}\n## This is a **quadratic objective function**!\nThe quadratic terms are $X_{ik}\\times X_{jk}$. This objective function is based on the **Quadratic Multiple Knapsack Problem (QMKP)**, formulated by @Hiley2006.\n:::\n\n## Objective Function in Julia\n\n[Question:]{.question} **How could we formulate this in Julia?**\n\n. . .\n\n::: {#df5fd652 .cell output-location='fragment' execution_count=5}\n``` {.julia .cell-code}\nQ = [2 1 2; 1 2 1; 2 1 2]\n\n@objective(warehouse_model,\n    Max,\n    sum(\n        X[skus[i], warehouses[k]] * X[skus[j], warehouses[k]] * Q[i,j]\n        for i in 2:length(skus)\n        for j in 1:i-1\n        for k in 1:length(warehouses)\n    )\n)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=6}\n$ X_{Socks,Hamburg}\\times X_{Smartphone,Hamburg} + X_{Socks,Berlin}\\times X_{Smartphone,Berlin} + 2 X_{Charger,Hamburg}\\times X_{Smartphone,Hamburg} + 2 X_{Charger,Berlin}\\times X_{Smartphone,Berlin} + X_{Charger,Hamburg}\\times X_{Socks,Hamburg} + X_{Charger,Berlin}\\times X_{Socks,Berlin} $\n:::\n:::\n\n\n---\n\n# [Constraints]{.flow} {.title}\n\n## What constraints?\n\n::: {.columns}\n::: {.column width=\"40%\"}\n\n![](https://images.beyondsimulations.com/ao/ao_split-warehouse.png){width=\"90%\"}\n\n:::\n\n::: {.column width=\"60%\"}\n[Question:]{.question} **What constraints?**\n\n::: {.fragment}\n- Allocate each SKU **at least once**\n- Warehouses have a **finite capacity**\n- Capacity is **not exceeded**\n:::\n:::\n:::\n\n---\n\n## Single Allocation Constraint?\n\n::: {.callout-important}\n## The goal of this constraint is to:\nEnsure that each SKU is allocated at least once.\n:::\n\n. . .\n\n::: {.callout-note}\n## We need the following variable:\n\n- $X_{i,k}$ - 1, if SKU $i\\in\\mathcal{I}$ is stored in  $k\\in\\mathcal{K}$, 0 otherwise\n\n:::\n\n. . .\n\n[Question:]{.question} **What could the constraint look like?**\n\n## Single Allocation Constraint\n\n$$\\sum_{k \\in \\mathcal{K}} X_{ik} \\geq 1 \\quad \\forall i \\in \\mathcal{I}$$\n\n. . .\n\n::: {.callout-note}\n## Remember, this is the variable:\n\n- $X_{i,k}$ - 1, if SKU $i\\in\\mathcal{I}$ is stored in  $k\\in\\mathcal{K}$, 0 otherwise\n\n:::\n\n. . .\n\n[Question:]{.question} **How could we change the constraint to ensure that each SKU is allocated only once?**\n\n. . .\n\n[Question:]{.question} **How could we add the constraint in Julia?**\n\n## Single Allocation in Julia\n\n::: {#d3ca73f3 .cell output-location='fragment' execution_count=6}\n``` {.julia .cell-code}\n@constraint(warehouse_model, single_allocation[i in skus],\n    sum(X[i, k] for k in warehouses) >= 1\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n1-dimensional DenseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, ScalarShape},1,...} with index sets:\n    Dimension 1, [\"Smartphone\", \"Socks\", \"Charger\"]\nAnd data, a 3-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, ScalarShape}}:\n single_allocation[Smartphone] : X[Smartphone,Hamburg] + X[Smartphone,Berlin] ≥ 1\n single_allocation[Socks] : X[Socks,Hamburg] + X[Socks,Berlin] ≥ 1\n single_allocation[Charger] : X[Charger,Hamburg] + X[Charger,Berlin] ≥ 1\n```\n:::\n:::\n\n\n---\n\n## Capacity Constraints?\n\n::: {.callout-important}\n## The goal of these constraints is to:\nEnsure that the capacity of each warehouse is not exceeded.\n:::\n\n. . .\n\n::: {.callout-note}\n## We need the following variables and parameters:\n\n- $X_{i,k}$ - 1, if SKU $i\\in\\mathcal{I}$ is stored in  $k\\in\\mathcal{K}$, 0 otherwise\n- $c_k$ - Storage space of warehouse $k\\in\\mathcal{K}$\n\n:::\n\n. . .\n\n[Question:]{.question} **What could the second constraint be?**\n\n## Capacity Constraints\n\n$$\\sum_{i \\in \\mathcal{I}} X_{ik} \\leq c_k \\quad \\forall k \\in \\mathcal{K}$$\n\n. . .\n\n[And that's basically it!]{.highlight}\n\n. . .\n\n[Question:]{.question} **How could we add the second constraint in Julia?**\n\n## Capacity Constraints in Julia\n\n::: {#00d69bb5 .cell output-location='fragment' execution_count=7}\n``` {.julia .cell-code}\ncapacities = Dict(\"Hamburg\" => 2, \"Berlin\" => 1) # Add capacities\n\n@constraint(warehouse_model, capacity[k in warehouses],\n    sum(X[i, k] for i in skus) <= capacities[k]\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n1-dimensional DenseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape},1,...} with index sets:\n    Dimension 1, [\"Hamburg\", \"Berlin\"]\nAnd data, a 2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n capacity[Hamburg] : X[Smartphone,Hamburg] + X[Socks,Hamburg] + X[Charger,Hamburg] ≤ 2\n capacity[Berlin] : X[Smartphone,Berlin] + X[Socks,Berlin] + X[Charger,Berlin] ≤ 1\n```\n:::\n:::\n\n\n---\n\n## QMK Model\n\n$$\\text{maximize} \\quad \\sum_{i=2}^{\\mathcal{I}} \\sum_{j=1}^{i-1} \\sum_{k \\in \\mathcal{K}} X_{ik}\\times X_{jk} \\times q_{ij}$$\n\n\nsubject to:\n\n$$\n\\begin{align*}\n\t\t\t\t& \\sum_{k \\in \\mathcal{K}} X_{ik} \\geq 1 && \\forall i \\in \\mathcal{I}\\\\\n\t\t\t\t& \\sum_{i \\in \\mathcal{I}} X_{ik} \\leq c_{k} && \\forall k \\in \\mathcal{K}\\\\\n\t\t\t\t& X_{ik} \\in \\{0,1\\}  && \\forall i \\in \\mathcal{I}, \\forall k \\in \\mathcal{K}\n\\end{align*}\n$$\n\n## QMK Model in Julia\n\n::: {#7221b0ff .cell output-location='fragment' execution_count=8}\n``` {.julia .cell-code}\nset_attribute(warehouse_model, \"display/verblevel\", 0) # Hide solver output\noptimize!(warehouse_model)\n\nprintln(\"The optimal objective value is: \", objective_value(warehouse_model))\nprintln(\"The optimal solution is: \", value.(X))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe optimal objective value is: 2.0\nThe optimal solution is: 2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, [\"Smartphone\", \"Socks\", \"Charger\"]\n    Dimension 2, [\"Hamburg\", \"Berlin\"]\nAnd data, a 3×2 Matrix{Float64}:\n  1.0  0.0\n -0.0  1.0\n  1.0  0.0\n```\n:::\n:::\n\n\n---\n\n# [Model Characteristics]{.flow} {.title}\n\n## Characteristics\n\n::: {.incremental}\n- Is the model formulation **linear/ non-linear?**\n- What kind of **variable domain** do we have?\n- Do we know the **split-orders** based on the **objective value?**\n- Why **couldn't we use HiGHS** as solver?\n:::\n\n\n## Choosing a solver\n\n- Identify **problem structure**, e.g. LP, MIP, NLP, QCP, MIQCP, ...\n- What is the **size** of the problem?\n- Is a **commercial** solver needed?\n\n. . .\n\n::: {.callout-note}\n## Commercial Solvers\nCommercial solvers are **faster** and **more robust** as open source solvers but also **more expensive**. During your studies, you can use most of them for free though! Nonetheless, we will only use open source solvers in this course.\n:::\n\n## Global vs Local Optimality\n\n[![Local vs Global Optimum by Christoph Roser](https://i0.wp.com/www.allaboutlean.com/wp-content/uploads/2018/08/Local-Global-Optimum.png?w=1040&ssl=1){width=\"80%\"}](https://www.allaboutlean.com/polca-pros-and-cons/local-global-optimum/)\n\n---\n\n## Model Assumptions\n\n[Questions:]{.question} **On model assumptions**\n\n::: {.incremental}\n\n- What assumptions have we made?\n- Problem with allocating SKUs to multiple warehouses?\n- What else might pose a problem in the real world?\n\n:::\n\n# [Impact]{.flow} {.title}\n\n## {.loud-slide}\n::: {.r-fit-text}\nCan this be\n\napplied?\n:::\n\n::: footer\n:::\n\n## Problem Size is Crucial\n\n- Up to 10,000 SKUs →  **commercial solvers**\n- More than 10,000 SKUs → **heuristics**\n- For example, the [CHI]{.highlight} heuristic\n\n. . .\n\n::: {.callout-note}\n\n## CHI-Heuristic\n\nDetect dependencies between products and allocate them accordingly, as products within orders can have dependencies and products are bought with different frequencies!\n\n:::\n\n---\n\n## Case Study\n\n- More than 100,000 SKUs and several millions of orders\n- Comparison of **different heuristics**[^opt_not]\n    - **CHI**: based on Chi-Square tests @vlcek_optimizing_2024\n    - **GP, GO, GS, BS**: based on greedy algorithms [@Catalan2012]\n    - **RA**: Random allocation of SKUs to warehouses\n\n[^opt_not]:QMKP is not applicable for instance in case study\n\n## Real Data Set\n\n![](https://images.beyondsimulations.com/ao/ao_split-case.png){width=\"80%\"}\n\n## Conclusion\n\n- Splits are **of no benefit**, except **faster customer deliveries**\n- [Increase workload, packaging and shipping costs]{.highlight}\n- Mathematical Optimisation of **\"full\" problem not solvable**\n- **CHI** Heuristic close to mathematical optimisation\n\n::: {.callout-note}\n## And that's it for todays lecture!\n\nWe now have covered the Quadratic Multiple Knapsack Problem and are ready to start solving some tasks in the upcoming tutorial.\n:::\n\n## {.loud-slide}\n::: {.r-fit-text}\nQuestions?\n:::\n\n::: footer\n:::\n\n---\n\n# [Literature]{.flow} {.title}\n\n## Literature I\n\nFor more interesting literature to learn more about Julia, take a look at the [literature list](../general/literature.qmd) of this course.\n\n",
    "supporting": [
      "lecture-06-ordersplit_files"
    ],
    "filters": [],
    "includes": {}
  }
}