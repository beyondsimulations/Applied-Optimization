---
title: "Tutorial III.I - Functions in Julia"
subtitle: "Applied Optimization with Julia"

format:
    html:
        theme: litera
        highlight-style: arrow
        linkcolor: "#a60000"
        code-copy: true
        code-link: true
        toc: true
        toc-location: right
        code-overflow: wrap
    pdf: 
        documentclass: report
        geometry:
            - margin=1in
        fontfamily: roboto
        fontfamilyoptions: sfdefault
        colorlinks: true     
    ipynb:
        code-copy: true
        code-overflow: wrap

engine: julia
---

# Introduction

This interactive Julia script is a comprehensive guide to understanding functions in Julia. Dive into the creation and usage of functions, grasp the concept of scope within functions, explore returning values, use anonymous functions, and leverage multiple dispatch for versatile function behavior. Follow the instructions, input your code in the designated areas, and verify your implementations with `@assert` statements.

## Section 1 - Creating and Calling Functions

Functions in Julia encapsulate reusable code and can be defined using the `function` keyword or shorthand syntax. After the keyword, you name the function and write the parameters in parentheses. Later, you can call the function by writing the name of the function followed by the parameters in parentheses. For example:

```{julia}
function multiply(a,b)
   a * b
end
multiply(10, 5)
```

This function takes two parameters, multiplies them, and returns the result implicitly. In Julia, the last expression is automatically returned, making the `return` keyword optional. If you explicitly use the `return` keyword in the function, it will return the value immediately once the function encounters the keyword and stops the further execution of the function. That way, you can also use the keyword in conditional statements and use it to return a value based on a condition. For example:

```{julia}
function do_something(a,b)
   if a > b
      return a * b
   else
      return a + b
   end
end
println("The result of do_something(10, 5) is $(do_something(10, 5))")
println("The result of do_something(5, 10) is $(do_something(5, 10))")
```

## Exercise 1.1 - Define and Test a Simple Addition Function

Define and Test a Simple Addition Function. Define a function `add` that takes two parameters and returns their sum.

```{julia}
#| eval: false
# YOUR CODE BELOW

# Test your function
@assert add(10, 5) == 15 "The sum computed is $(add(10, 5)) but should be 15."
println("The sum computed is $(add(10, 5)), wonderful!")
```

## Section 2 - Scope within Functions
    
Variables declared inside a function are local to that function and are not accessible outside. If you want to access the variable outside of the function, you have to explicitly return it as already shown above. You can do this by passing `return` in front of the variable you want to return from the function.

## Exercise 2.1 - Return a Local Variable

Try to execute the following block of code. The objective is to understand how to return the `local_variable_one` from the function `scope_test`. Your task is to change the function, to return the value of `local_variable_one`.

```{julia}
#| eval: false
# YOUR CHANGES BELOW
function scope_test()
    local_variable_one = 10
    local_variable_two = 20
end

# YOUR CHANGES ABOVE
# Test your function
@assert scope_test() == 10 "The value exported is $(scope_test())."
println("The value exported is $(scope_test()), you solved it!")
```

## Exercise 2.2 - Define an Implicit Return Function

Define and test an implicit return function. Define a function `subtract` that takes two parameters and implicitly returns their difference. The implicit return feature makes your code cleaner and more concise.

```{julia}
#| eval: false
# YOUR CODE BELOW

# Test your function
@assert subtract(10, 5) == 5  "The difference computed is $(subtract(10, 5)) but should be 5."
println("The difference computed is $(subtract(10, 5)), perfect!")
```

## Section 3 - Multiple Dispatch

Multiple dispatch in Julia allows defining function behavior based on argument types, promoting code reuse and clarity. It's a powerful feature for designing flexible and extensible functions. We first define a generic version and then provide specific implementations for different types:

```{julia}
#| eval: true
# Generic operation for objects of all types.
function operation(a, b)
    "Generic operation for objects of type $(typeof(a)) and $(typeof(b))"
end

# The specific implementations are:
operation(a::Number, b::Number) = a + b        # Specific method for Number types.
operation(a::String, b::String) = string(a, b) # Specific method for String types.

# Test with different types of arguments.
result1 = operation(10, 20)
println(result1)
result2 = operation("Hello, ", "World!")
println(result2)
result3 = operation("Hello, ", 20)
println(result3)
```

## Exercise 3.1 - Match Results to Assertions

Match the results from the previous example to the correct assertions:

```{julia}
#| eval: false
# YOUR CHANGES BELOW
@assert result2 == 30 "result1 should be the sum of two numbers"
@assert result3 == "Hello, World!" "result2 should be the concatenation of two strings"
@assert result1 == "Generic operation for objects of type String and Int64" "result3 should use the generic operation"
println("You solved it, the assertions are now correct!")
```

::: {.callout-tip}
**Hint**: Look at the types of arguments used in each `operation` call and match them to the appropriate method.
:::

## Conclusion

Great work! You've just completed the tutorial on functions in Julia. You now have a first understanding of how to create, use, and understand functions in Julia. Continue to the next file to learn more.

{{< include ../include/tutorial_end.qmd >}}